#!/usr/bin/env python3
# author: @whattheslime
from argparse import ArgumentParser, Namespace
from asyncio import run
from datetime import datetime
from pathlib import Path
from packaging.version import Version as v
from requests import Session, RequestException
from re import search
from urllib.parse import urljoin

from lib.args import (
    add_output_args, add_plugins_arg, add_session_args, 
    load_lists, load_plugins, parse_output,  
)
from lib.asyncqueue import AsyncQueue
from lib.interrupt import sigint_handler
from lib.logger import info, Progress, safe, vuln, warn
from lib.session import http_session


#: ASCII art logo.
logo = """
  \033[34;1m__      __\033[94m     ___ _           _   
  \033[34;1m\ \    / / __\033[94m / __| |_  ___ __| |__
   \033[34;1m\ \/\/ / '_ \\\033[94m (__| ' \/ -_) _| / /
    \033[34;1m\_/\_/| .__/\033[94m\___|_||_|___\__|_\_\\
          \033[34m|_|\033[0m            @whattheslime
"""

# Default user arguments values.
default_workers = 20
default_output = Path(__file__).parent / "results"
default_directory = f"wp-content/plugins"

# Regular expressions.
version_regex = r"((?:\d+\.)+\d+)"
readme_regex = f"Stable tag:\s+{version_regex}"

#: Plugins files that may contains plugin version, sorted by occurences in 
#: existing plugins.
versions_files = {        
    "readme.txt":       readme_regex,
    "README.txt":       readme_regex,
    "README.md":        readme_regex,
    "changelog.txt":    version_regex,
    "readme.md":        readme_regex,
    "CHANGELOG.md":     version_regex,
    "Readme.txt":       readme_regex,
}


def check_version(
    session: Session, target: str, directory: str, slug: str, max_version: v, 
    output: Path, verbose: bool) -> bool:
    """Look for versions in plugins common files and compare it with the one 
    passed in argument"""
    #: Will be set to True if the founded version is equal to or less than the 
    #: requested version.
    is_vulnerable = False

    # Check if target has previous requests errors to skip and prevent time 
    # sloss.
    if target in session.errors:
        return False

    for file, regex in versions_files.items():
        try:
            url = urljoin(target, f"{directory}/{slug}/{file}")
            response = session.get(url, allow_redirects=False)
            session.nb_requests += 1
        except RequestException as exception:
            session.errors.add(target)
            warn(target, exception)
            return False
        
        # Search version in file.
        title = search(r"<title>(.*)</title>", response.text)
        if response.status_code == 200 and not title:
            match = search(regex, response.text)
            if match:
                # Check if version is vulnerable.
                version = v(match.group(1))
                message = f"{target} {slug}:{version}"
                
                # Version should be vulnerable.
                if version <= max_version:
                    is_vulnerable = True
                    vuln(message)

                    # Write result in log file.
                    if output:
                        output.open("a").write(f"{message}\n")
                
                # Version should be safe.
                else:
                    safe(message)
                
                if verbose:
                    info(response.url)

                return is_vulnerable   
    return False


def parse_args() -> Namespace:
    """Function to parse user arguments."""
    parser = ArgumentParser()
    
    # Plugins arguments.
    add_plugins_arg(parser)

    # Check arguments.
    parser.add_argument(
        "-t", "--targets", type=str, nargs="+", required=True,
        help="target url (e.g. http://target.com) or file path containing urls"
        " separated by newlines")

    parser.add_argument(
        "-d", "--plugins-directory", type=str, default=default_directory,
        help=f"plugins installation dirctory (default: {default_directory})")

    parser.add_argument(
        "-w", "--workers", type=int, default=default_workers,
        help=f"number of max concurrent workers (default {default_workers})")

    # HTTP session arguments.
    add_session_args(parser)

    # Output arguments.
    add_output_args(parser, default_output)

    return parser.parse_args()


async def main():
    """Program entry point."""
    #: Programme timer.
    start_time = datetime.now()
    # Set signal interrupt handler.
    sigint_handler()
    #: Vulnerables founded plugins counter.
    vuln_plugins = 0

    # Parse user arguments.
    args = parse_args()
    directory = args.plugins_directory
    output = parse_output(args.output)
    plugins = load_plugins(args.plugins)
    targets = load_lists(args.targets)
    verbose = args.verbose

    if directory.endswith("/"):
        directory = directory[:-1]

    with http_session(args.headers, args.proxy) as session:
        asyncqueue = AsyncQueue(args.workers)
        
        info("Loading targets and plugins...")
        
        for target in targets:
            for slug, version in plugins:                
                asyncqueue.enqueue(
                    check_version, 
                    session, target, directory, slug, version, output, verbose)
        
        total = len(targets) * len(plugins)

        info(f"{len(targets)} target(s) and {len(plugins)} plugin(s) loaded!")
        info("Starting scan...")
        
        with Progress(total) as bar:
            async for is_vulnerable in asyncqueue.dequeue():
                bar.update()
                vuln_plugins += int(is_vulnerable)

    info(f"Elapsed time:    {datetime.now() - start_time}")
    info(f"Plugins found:   {vuln_plugins}")
    info(f"Requests sent:   {session.nb_requests}")

    if vuln_plugins:
        info(f"Results file:    {output}")

if __name__ == "__main__":
    print(logo)
    run(main())
